# node进程调度

## 服务模型

> 假设响应时间 N 秒，进程上线 M 个，一个进程中可有 L个 线程占用量

| 名称     | 介绍                                                      | 优点                                                 | 缺点                                                         | QPS                  |
| -------- | --------------------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------ | -------------------- |
| 同步     | 按次序执行                                                | 有序                                                 | 并发时耗时太久                                               | 1/N                  |
| 复制进程 | 每个连接都用进程来服务,进程间无法共享数据需要复制一个进程 | 快速处理并发                                         | 启动缓慢（预复制 prefork解决）、太多导致内存不足             | M/N                  |
| 多线程   | 线程处理请求服务                                          | 相比于进程可以共享数据，线程堆栈占用内存小于进程分配 | 内存一样会不足当线程堆栈过多，一个CPU核心为了让线程均匀使用资源，需要切换线程 | M*L/N (忽略线程切换) |
| 事件驱动 | 单线程，类似发布订阅者模式                                | 减少内存，线程切换的开销                             | 受限于CPU计算能力，只用到单核                                | 受限于CPU            |



> 利用ipc进程通信和句柄传递

<img src="https://raw.githubusercontent.com/caifeng123/pictures/master/%E5%A4%9A%E8%BF%9B%E7%A8%8B%20(1).png" style="display: inline" />

## 负载均衡

> 多进程之间监听相同端口，使得请求能分散在多个进程上处理。为了让大家平均工作量，采用抢占式策略实现负载均衡。

问题：node导致计算机繁忙原因：I/O、CPU。影响抢占是CPU的繁忙程度，当IO繁忙，cpu空闲时，也会参与抢占，导致当前进程任务过多。

解决：使用轮叫调度【以轮叫的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。算法的优点是其简洁性，它无需记录当前所有连接的状态，不管服务器上实际的连接数和系统负载，所以它是一种无状态调度。】
