

> Node的特色：事件驱动异步I/O

| 线程            | 单线程                                                       | 多线程                                                       |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| <div>问题</div> | 当遇到耗时事件（例如I/O），要等执行完成再继续，导致硬件（cpu）一直空闲等待。 | 可以多条线程并行，但有时需要线程直接的通信/线程结果顺序依赖，需要添加锁去进行限制 |

当单线程 + 异步I/O的组合就形成了node-不需要关注锁，遇到I/O时也可以先执行其他操作等



OS对于I/O来说，只有阻塞与非阻塞

|      | 阻塞                                                        | 非阻塞                              |
| ---- | ----------------------------------------------------------- | ----------------------------------- |
| I/O  | 等系统内核完成操作才可继续<br/>磁盘训到、读取数据、复制数据 | 调用后立即返回<br/>需要不停轮询结果 |
| cpu  | 等待                                                        | 轮询导致状态判断增加。对cpu浪费     |

- 完美的异步I/O：单线程，非阻塞调用，立即返回，主线程处理其他事物，内核返回数据（+信号量），主线程处理。

但操作系统不支持

- 只能通过线程池实现异步I/O：

主线程管理I/O操作，分发线程1和2处理两个任务，线程1处理后返回主线程，主线程执行操作，线程2处理后返回主线程，主线程执行操作。

- windows基于IOCP实现，底层也是线程池，但线程池由os内核管理

## 异步I/O模型

异步I/O模型由事件循环、观察者、请求对象、I/O线程池构成

- 事件循环

当进程启动时，node生成一个while(true)循环，每次执行循环体称为Tick，每次循环都会 **去判断是否存在事件等待处理** ，有相应回调等待执行则执行，否则继续循环

- 观察者

如何判断 **是否存在有事件等待处理** ？每一个观察者将对同种事件进行观察，tick也将会直接去询问观察者。例如：网络请求观察者、文件I/O观察者等

- 请求对象

异步I/O过程中的中间产物。我们知道核心js调用模块后，会去找到相应的C/C++模块代码执行。例如当我们调用 `fs.open()` 时，会将回调函数和执行任务等状态进行组合成请求对象，将其送入下层的线程池中执行/处理回调，都会用当请求对象。

- I/O线程池

上面已经讲过，不再重复

> js是单线程的，node本身却是多线程的（使用到线程池）



## 非I/O的异步api

> setTimeout() 、setInterval()、setImmediate()、process.nextTick()

![img](https://raw.githubusercontent.com/caifeng123/pictures/master/16f3b451c5239b28%7Etplv-t2oaga2asx-watermark.awebp)

- setTimeout() 、setInterval()
  - 属于定时器观察者
  - 原理类似异步I/O模型（只需前三步，不需要I/O线程池）,创建定时器插入到定时器观察者内部的红黑树中。每次tick执行，都会从红黑树中迭代取出定时器，观察是否超时，从而执行回调函数。
  - 缺点：不精确。假设一个定时器任务设定10ms后执行，在9ms时有一个任务占用5ms的cpu时间片，当下一次循环到定时器任务时，已经超时4ms了。

- process.nextTick(fn)
  - 在每个eventloop之间都会去检测执行。
  - 相比于setTimeout(fn, 0) 更为轻量。process.nextTick每次调用会将回调函数放入队列中，在下一次tick时，按顺序执行时间复杂度为O(1)。相比setTimeout 先将定时器插入观察者红黑树，再每次tick从红黑树中校验，复杂度为O(lg(n))
- setImmediate()
  - 属于check观察者
  - 和process.nextTick(fn)类似，都是立即执行的异步函数。
  - 将任务放在链表中，每次tick取出其一执行，为保证cpu时间片
