

> Node的特色：事件驱动异步I/O

| 线程            | 单线程                                                       | 多线程                                                       |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| <div>问题</div> | 当遇到耗时事件（例如I/O），要等执行完成再继续，导致硬件（cpu）一直空闲等待。 | 可以多条线程并行，但有时需要线程直接的通信/线程结果顺序依赖，需要添加锁去进行限制 |

当单线程 + 异步I/O的组合就形成了node-不需要关注锁，遇到I/O时也可以先执行其他操作等



OS对于I/O来说，只有阻塞与非阻塞

|      | 阻塞                                                        | 非阻塞                              |
| ---- | ----------------------------------------------------------- | ----------------------------------- |
| I/O  | 等系统内核完成操作才可继续<br/>磁盘训到、读取数据、复制数据 | 调用后立即返回<br/>需要不停轮询结果 |
| cpu  | 等待                                                        | 轮询导致状态判断增加。对cpu浪费     |

- 完美的异步I/O：单线程，非阻塞调用，立即返回，主线程处理其他事物，内核返回数据（+信号量），主线程处理。

但操作系统不支持

- 只能通过线程池实现异步I/O：

主线程管理I/O操作，分发线程1和2处理两个任务，线程1处理后返回主线程，主线程执行操作，线程2处理后返回主线程，主线程执行操作。

- windows基于IOCP实现，底层也是线程池，但线程池由os内核管理

## 异步I/O模型

异步I/O模型由事件循环、观察者、请求对象、I/O线程池构成

- 事件循环

当进程启动时，node生成一个while(true)循环，每次执行循环体称为Tick，每次循环都会 **去判断是否存在事件等待处理** ，有相应回调等待执行则执行，否则继续循环

- 观察者

如何判断 **是否存在有事件等待处理** ？每一个观察者将对同种事件进行观察，tick也将会直接去询问观察者。例如：网络请求观察者、文件I/O观察者等

- 请求对象

异步I/O过程中的中间产物。我们知道核心js调用模块后，会去找到相应的C/C++模块代码执行。例如当我们调用 `fs.open()` 时，会将回调函数和执行任务等状态进行组合成请求对象，将其送入下层的线程池中执行/处理回调，都会用当请求对象。

- I/O线程池

上面已经讲过，不再重复

> js是单线程的，node本身却是多线程的（使用到线程池）

